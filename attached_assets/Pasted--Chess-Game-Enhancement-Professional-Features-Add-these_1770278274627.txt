# üéÆ Chess Game Enhancement - Professional Features

Add these professional chess features to make the game tournament-quality:

1. ‚úÖ Bigger chess board
2. ‚úÖ Real-time clock updates (counting down live)
3. ‚úÖ Pre-moves (queue next move while opponent is thinking)
4. ‚úÖ Resign button
5. ‚úÖ Abort button (only before first move)
6. ‚úÖ Username display
7. ‚úÖ Material count (show captured pieces value)

---

## FEATURE 1: Bigger Chess Board

**File:** `client/src/components/ChessBoard.tsx`

Find the wrapper div (around line 40) and change the max-width:

**Current:**
```typescript
<div className="w-full max-w-[90vw] md:max-w-[600px] aspect-square ...">
```

**Change to:**
```typescript
<div className="w-full max-w-[95vw] md:max-w-[700px] lg:max-w-[800px] aspect-square shadow-2xl shadow-black/50 rounded-lg overflow-hidden border-4 border-secondary/50">
```

This makes the board:
- Mobile: 95% of viewport width
- Tablet: 700px
- Desktop: 800px (much bigger!)

---

## FEATURE 2: Real-Time Clock Updates

**File:** `client/src/pages/GameRoom.tsx`

Add a new hook for live timer updates. Add this AFTER the existing hooks (around line 55):

```typescript
// Live timer updates - count down in real-time
const [liveWhiteTime, setLiveWhiteTime] = useState(game?.whiteTime || 600);
const [liveBlackTime, setLiveBlackTime] = useState(game?.blackTime || 600);

useEffect(() => {
  if (!game || game.status !== 'playing') return;
  
  setLiveWhiteTime(game.whiteTime);
  setLiveBlackTime(game.blackTime);
  
  const interval = setInterval(() => {
    if (game.turn === 'w') {
      setLiveWhiteTime(prev => Math.max(0, prev - 1));
    } else {
      setLiveBlackTime(prev => Math.max(0, prev - 1));
    }
  }, 1000);
  
  return () => clearInterval(interval);
}, [game?.whiteTime, game?.blackTime, game?.turn, game?.status]);
```

Then REPLACE the timer display (around line 155 and 165) with:

```typescript
{/* White Timer */}
<span className="font-mono text-lg">
  {Math.floor(liveWhiteTime / 60)}:{(liveWhiteTime % 60).toString().padStart(2, '0')}
</span>

{/* Black Timer */}
<span className="font-mono text-lg">
  {Math.floor(liveBlackTime / 60)}:{(liveBlackTime % 60).toString().padStart(2, '0')}
</span>
```

Add visual urgency when time is low. In the timer divs, add:

```typescript
{/* White Timer Card */}
<div className={`p-4 rounded-xl border ${
  game.turn === 'w' ? 'bg-primary/10 border-primary/30' : 'bg-card border-border'
} ${liveWhiteTime < 30 ? 'animate-pulse border-red-500' : ''}`}>

{/* Black Timer Card */}
<div className={`p-4 rounded-xl border ${
  game.turn === 'b' ? 'bg-primary/10 border-primary/30' : 'bg-card border-border'
} ${liveBlackTime < 30 ? 'animate-pulse border-red-500' : ''}`}>
```

---

## FEATURE 3: Pre-moves System

**File:** `client/src/pages/GameRoom.tsx`

Add pre-move state (after the role state, around line 22):

```typescript
const [preMove, setPreMove] = useState<{from: Square, to: Square} | null>(null);
```

Modify the `onPieceDrop` function (around line 57) to handle pre-moves:

```typescript
const onPieceDrop = (sourceSquare: Square, targetSquare: Square, piece: string) => {
  if (!game) return false;
  if (game.status !== 'playing') return false;
  
  // If it's not our turn, save as pre-move
  if (game.turn !== role) {
    console.log('[PreMove] Queued:', { from: sourceSquare, to: targetSquare });
    setPreMove({ from: sourceSquare, to: targetSquare });
    // Return true to show the move visually
    return true;
  }
  
  // Clear any pre-move when making actual move
  setPreMove(null);

  try {
    const move = chess.move({
      from: sourceSquare,
      to: targetSquare,
      promotion: piece[1].toLowerCase() ?? "q",
    });

    if (!move) return false;

    sendMove({
      from: sourceSquare,
      to: targetSquare,
      promotion: "q",
    });

    return true;
  } catch (e) {
    return false;
  }
};
```

Add auto-execution of pre-moves when turn changes:

```typescript
// Execute pre-move when it becomes our turn
useEffect(() => {
  if (!game || !preMove || game.turn !== role || game.status !== 'playing') return;
  
  console.log('[PreMove] Executing queued move:', preMove);
  
  try {
    const move = chess.move({
      from: preMove.from,
      to: preMove.to,
      promotion: "q",
    });

    if (move) {
      sendMove({
        from: preMove.from,
        to: preMove.to,
        promotion: "q",
      });
    }
  } catch (e) {
    console.error('[PreMove] Invalid pre-move:', e);
  }
  
  setPreMove(null);
}, [game?.turn, game?.status, role, preMove, chess, sendMove]);
```

Add visual indicator for pre-moves in ChessBoard component:

```typescript
// In ChessBoard.tsx, add to customSquareStyles:
const customSquareStyles = useMemo(() => {
  const styles: Record<string, React.CSSProperties> = {};
  if (lastMove) {
    styles[lastMove.from] = { backgroundColor: 'rgba(255, 255, 0, 0.4)' };
    styles[lastMove.to] = { backgroundColor: 'rgba(255, 255, 0, 0.4)' };
  }
  // Add pre-move highlighting if provided as prop
  return styles;
}, [lastMove]);
```

---

## FEATURE 4 & 5: Resign and Abort Buttons

**File:** `client/src/pages/GameRoom.tsx`

Add these functions after `onPieceDrop`:

```typescript
const handleResign = async () => {
  if (!game || game.status !== 'playing') return;
  
  const confirmed = window.confirm('Are you sure you want to resign?');
  if (!confirmed) return;
  
  try {
    const response = await fetch(`/api/games/${game.code}/resign`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ playerId: getPlayerId(), role }),
    });
    
    if (!response.ok) throw new Error('Failed to resign');
    
    // Game state will update via WebSocket
  } catch (error) {
    console.error('Resign error:', error);
  }
};

const handleAbort = async () => {
  if (!game || game.status !== 'waiting') return;
  
  const confirmed = window.confirm('Abort this game?');
  if (!confirmed) return;
  
  try {
    const response = await fetch(`/api/games/${game.code}/abort`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ playerId: getPlayerId() }),
    });
    
    if (!response.ok) throw new Error('Failed to abort');
    
    // Redirect to home
    setLocation('/');
  } catch (error) {
    console.error('Abort error:', error);
  }
};

function getPlayerId() {
  return localStorage.getItem('chess_player_id') || '';
}
```

Add buttons in the sidebar (after the player cards, around line 173):

```typescript
{/* Game Actions */}
{game.status === 'playing' && role !== 'spectator' && (
  <div className="mt-4">
    <Button 
      variant="destructive" 
      className="w-full"
      onClick={handleResign}
    >
      Resign
    </Button>
  </div>
)}

{game.status === 'waiting' && game.whiteId && !game.blackId && (
  <div className="mt-4">
    <Button 
      variant="outline" 
      className="w-full"
      onClick={handleAbort}
    >
      Abort Game
    </Button>
  </div>
)}
```

**Add Server Routes** - File: `server/routes.ts`

Add these new endpoints after the existing routes (around line 40):

```typescript
// Resign endpoint
app.post('/api/games/:code/resign', async (req, res) => {
  const { code } = req.params;
  const { role } = req.body;
  
  const game = await storage.getGame(code);
  if (!game || game.status !== 'playing') {
    return res.status(400).json({ message: 'Cannot resign this game' });
  }
  
  // Opposite player wins
  const winner = role === 'w' ? 'b' : 'w';
  await storage.setWinner(code, winner);
  
  const updatedGame = await storage.getGame(code);
  
  // Broadcast to both players
  if (rooms.has(code)) {
    const payload = JSON.stringify({ type: 'game_state', game: updatedGame });
    rooms.get(code)!.forEach(client => {
      if (client.readyState === WebSocket.OPEN) client.send(payload);
    });
  }
  
  res.json({ success: true });
});

// Abort endpoint
app.post('/api/games/:code/abort', async (req, res) => {
  const { code } = req.params;
  
  const game = await storage.getGame(code);
  if (!game) {
    return res.status(404).json({ message: 'Game not found' });
  }
  
  // Can only abort if game hasn't started or no moves made
  if (game.status === 'playing' && game.pgn && game.pgn.length > 0) {
    return res.status(400).json({ message: 'Cannot abort after moves' });
  }
  
  await storage.setGameStatus(code, 'aborted');
  
  res.json({ success: true });
});
```

**Add to storage.ts:**

```typescript
async setGameStatus(code: string, status: string): Promise<Game> {
  const [game] = await db.update(games)
    .set({ status })
    .where(eq(games.code, code))
    .returning();
  return game;
}
```

---

## FEATURE 6: Username Display

**Option A: Simple (Username from localStorage)**

Add username input to the Home page (around line 60):

```typescript
const [username, setUsername] = useState(() => {
  return localStorage.getItem('chess_username') || '';
});

// Add this input before the "Host New Game" button:
<div className="space-y-2">
  <label className="text-sm text-muted-foreground">Your Name (optional)</label>
  <Input
    placeholder="Enter your name"
    value={username}
    onChange={(e) => {
      setUsername(e.target.value);
      localStorage.setItem('chess_username', e.target.value);
    }}
    maxLength={20}
    className="h-12 text-center"
  />
</div>
```

Update player display in GameRoom (around line 159 and 169):

```typescript
{/* White Player */}
{game.whiteId ? (
  role === 'w' 
    ? localStorage.getItem('chess_username') || "You"
    : "Opponent"
) : "Waiting..."}

{/* Black Player */}
{game.blackId ? (
  role === 'b' 
    ? localStorage.getItem('chess_username') || "You"
    : "Opponent"
) : "Waiting..."}
```

---

## FEATURE 7: Material Count Display

**File:** Create new file `client/src/components/MaterialCount.tsx`

```typescript
import { useMemo } from 'react';

interface MaterialCountProps {
  fen: string;
}

const PIECE_VALUES: Record<string, number> = {
  'p': 1, 'n': 3, 'b': 3, 'r': 5, 'q': 9,
  'P': 1, 'N': 3, 'B': 3, 'R': 5, 'Q': 9,
};

const PIECE_SYMBOLS: Record<string, string> = {
  'p': '‚ôü', 'n': '‚ôû', 'b': '‚ôù', 'r': '‚ôú', 'q': '‚ôõ',
  'P': '‚ôô', 'N': '‚ôò', 'B': '‚ôó', 'R': '‚ôñ', 'Q': '‚ôï',
};

export function MaterialCount({ fen }: MaterialCountProps) {
  const material = useMemo(() => {
    const position = fen.split(' ')[0];
    const pieces = position.replace(/[/\d]/g, '');
    
    let whiteValue = 0;
    let blackValue = 0;
    const whitePieces: string[] = [];
    const blackPieces: string[] = [];
    
    for (const piece of pieces) {
      const value = PIECE_VALUES[piece] || 0;
      if (piece === piece.toUpperCase()) {
        whiteValue += value;
        if (piece !== 'K') whitePieces.push(piece);
      } else {
        blackValue += value;
        if (piece !== 'k') blackPieces.push(piece);
      }
    }
    
    const diff = whiteValue - blackValue;
    
    // Count captured pieces
    const capturedByWhite: Record<string, number> = {};
    const capturedByBlack: Record<string, number> = {};
    
    // Standard starting material
    const startPieces = { p: 8, n: 2, b: 2, r: 2, q: 1 };
    
    for (const [piece, count] of Object.entries(startPieces)) {
      const upperPiece = piece.toUpperCase();
      const whiteCount = whitePieces.filter(p => p === upperPiece).length;
      const blackCount = blackPieces.filter(p => p === piece).length;
      
      const whiteMissing = count - whiteCount;
      const blackMissing = count - blackCount;
      
      if (whiteMissing > 0) capturedByBlack[piece] = whiteMissing;
      if (blackMissing > 0) capturedByWhite[upperPiece] = blackMissing;
    }
    
    return { diff, capturedByWhite, capturedByBlack };
  }, [fen]);
  
  if (material.diff === 0) return null;
  
  const advantage = material.diff > 0 ? 'white' : 'black';
  const captured = material.diff > 0 ? material.capturedByWhite : material.capturedByBlack;
  const value = Math.abs(material.diff);
  
  return (
    <div className={`flex items-center gap-2 px-3 py-1.5 rounded-lg ${
      advantage === 'white' 
        ? 'bg-white/10 text-white' 
        : 'bg-black/10 text-white'
    }`}>
      <div className="flex gap-1">
        {Object.entries(captured).map(([piece, count]) => (
          <div key={piece} className="flex items-center">
            <span className="text-sm">{PIECE_SYMBOLS[piece]}</span>
            {count > 1 && <span className="text-xs ml-0.5">√ó{count}</span>}
          </div>
        ))}
      </div>
      <span className="text-xs font-bold">+{value}</span>
    </div>
  );
}
```

**Add to GameRoom.tsx:**

Import the component:
```typescript
import { MaterialCount } from "@/components/MaterialCount";
```

Add below each player card (after line 161 and 171):

```typescript
{/* After White player card */}
<MaterialCount fen={game.fen} />

{/* After Black player card */}
<MaterialCount fen={game.fen} />
```

---

## SUMMARY OF CHANGES

### Files to Modify:
1. ‚úÖ `client/src/components/ChessBoard.tsx` - Bigger board
2. ‚úÖ `client/src/pages/GameRoom.tsx` - Live timers, pre-moves, resign/abort, username
3. ‚úÖ `client/src/pages/Home.tsx` - Username input
4. ‚úÖ `server/routes.ts` - Resign/abort endpoints
5. ‚úÖ `server/storage.ts` - Add setGameStatus method

### Files to Create:
1. ‚úÖ `client/src/components/MaterialCount.tsx` - Material advantage display

---

## TESTING CHECKLIST

After implementing:

- [ ] Board is bigger (800px on desktop)
- [ ] Clocks count down in real-time every second
- [ ] Clock flashes red when under 30 seconds
- [ ] Can make pre-moves (drag piece when not your turn)
- [ ] Pre-move executes automatically when turn arrives
- [ ] Resign button works (opponent wins)
- [ ] Abort button shows only before first move
- [ ] Username displays if entered
- [ ] Material count shows captured pieces
- [ ] Material count shows point advantage (+3, +5, etc.)

---

## DEPLOYMENT

After testing locally:
1. Remove the red debug box if still visible
2. Test all features end-to-end
3. Deploy to production!

Your chess game will now be **tournament-quality** with all professional features! üèÜ‚ôüÔ∏è