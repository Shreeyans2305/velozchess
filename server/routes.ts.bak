import type { Express } from "express";
import { createServer, type Server } from "http";
import { WebSocketServer, WebSocket } from "ws";
import { storage } from "./storage";
import { api } from "@shared/routes";
import { Chess } from "chess.js"; // Validation logic

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {

  // Create Game
  app.post(api.games.create.path, async (req, res) => {
    const { timeControl = 600, increment = 0 } = req.body;
    console.log('[Create Game] Received:', { timeControl, increment, body: req.body });
    const game = await storage.createGame(timeControl, increment);
    console.log('[Create Game] Created game with:', { timeControl: game.timeControl, increment: game.increment });
    res.status(201).json(game);
  });

  // Join Game
  app.post(api.games.join.path, async (req, res) => {
    const { code } = req.body;
    const game = await storage.getGame(code);

    if (!game) {
      return res.status(404).json({ message: "Game not found" });
    }

    let role = 'spectator';
    if (!game.whiteId) role = 'w';
    else if (!game.blackId) role = 'b';

    res.json({ game, role });
  });

  app.get(api.games.get.path, async (req, res) => {
    const code = req.params.code as string;
    const game = await storage.getGame(code);
    if (!game) return res.status(404).json({ message: "Game not found" });
    res.json(game);
  });

  // Resign endpoint
  app.post('/api/games/:code/resign', async (req, res) => {
    const { code } = req.params;
    const { role } = req.body;

    const game = await storage.getGame(code);
    if (!game || game.status !== 'playing') {
      return res.status(400).json({ message: 'Cannot resign this game' });
    }

    const winner = role === 'w' ? 'b' : 'w';
    await storage.setWinner(code, winner, 'resignation');

    const updatedGame = await storage.getGame(code);
    if (rooms.has(code)) {
      const payload = JSON.stringify({ type: 'game_state', game: updatedGame });
      rooms.get(code)!.forEach(client => {
        if (client.readyState === WebSocket.OPEN) client.send(payload);
      });
    }
    res.json({ success: true });
  });

  // Abort endpoint
  app.post('/api/games/:code/abort', async (req, res) => {
    const { code } = req.params;
    const game = await storage.getGame(code);
    if (!game) return res.status(404).json({ message: 'Game not found' });

    if (game.status === 'playing' && game.pgn && game.pgn.length > 0) {
      return res.status(400).json({ message: 'Cannot abort after moves' });
    }

    await storage.setGameStatus(code, 'aborted');
    res.json({ success: true });
  });

  // WebSocket Server
  const wss = new WebSocketServer({ server: httpServer, path: '/ws' });
  const rooms = new Map<string, Set<WebSocket>>();

  wss.on('connection', (ws) => {
    let gameCode: string | null = null;
    let playerId: string | null = null;

    ws.on('message', async (data) => {
      try {
        const message = JSON.parse(data.toString());

        if (message.type === 'join') {
          gameCode = message.code;
          playerId = message.playerId as string;

          if (!gameCode || !playerId) return;

          const game = await storage.getGame(gameCode);
          if (!game) {
            ws.send(JSON.stringify({ type: 'error', message: 'Game not found' }));
            return;
          }

          // Assign Role and get the updated game state
          let updatedGame: any;
          if (game.whiteId === playerId || (!game.whiteId && game.blackId !== playerId)) {
            updatedGame = await storage.setPlayer(gameCode, 'w', playerId);
          } else if (game.blackId === playerId || !game.blackId) {
            updatedGame = await storage.setPlayer(gameCode, 'b', playerId);
          }

          if (!updatedGame) return;

          console.log(`[WebSocket] Player joined game ${gameCode}:`, {
            whiteId: updatedGame.whiteId,
            blackId: updatedGame.blackId,
            status: updatedGame.status
          });

          if (!rooms.has(gameCode)) rooms.set(gameCode, new Set());
          rooms.get(gameCode)!.add(ws);

          broadcast(gameCode, { type: 'game_state', game: updatedGame });
        }

        if (message.type === 'move') {
          if (!gameCode) return;
          const game = await storage.getGame(gameCode);
          if (!game || game.status !== 'playing') return;

          // Calculate time reduction
          const now = new Date();
          const elapsed = Math.floor((now.getTime() - new Date(game.lastMoveTime!).getTime()) / 1000);

          let whiteTime = game.whiteTime;
          let blackTime = game.blackTime;

          // Deduct time for the player who just moved, then add increment
          if (game.turn === 'w') {
            whiteTime = Math.max(0, whiteTime - elapsed);
            // Add increment after the move
            if (whiteTime > 0) {
              whiteTime += game.increment;
            }
          } else {
            blackTime = Math.max(0, blackTime - elapsed);
            // Add increment after the move
            if (blackTime > 0) {
              blackTime += game.increment;
            }
          }

          if (whiteTime === 0 || blackTime === 0) {
            const winner = whiteTime === 0 ? 'b' : 'w';
            await storage.setWinner(gameCode, winner, 'timeout');
            const finalGame = await storage.getGame(gameCode);
            broadcast(gameCode, { type: 'game_state', game: finalGame });
            return;
          }

          // Validate move
          const chess = new Chess(game.fen);
          try {
            const move = chess.move({
              from: message.from,
              to: message.to,
              promotion: message.promotion || 'q'
            });

            if (move) {
              let winner: 'w' | 'b' | 'draw' | undefined;
              let endReason: string | undefined;

              if (chess.isCheckmate()) {
                winner = chess.turn() === 'w' ? 'b' : 'w';
                endReason = 'checkmate';
              } else if (chess.isStalemate()) {
                winner = 'draw';
                endReason = 'stalemate';
              } else if (chess.isInsufficientMaterial()) {
                winner = 'draw';
                endReason = 'insufficient_material';
              } else if (chess.isThreefoldRepetition() || chess.isDraw()) {
                winner = 'draw';
                endReason = 'stalemate';
              }

              const updatedGame = await storage.updateGameState(
                gameCode,
                chess.fen(),
                chess.pgn(),
                chess.turn(),
                { from: message.from, to: message.to },
                whiteTime,
                blackTime
              );

              if (winner && endReason) {
                await storage.setWinner(gameCode, winner, endReason);
              }

              const finalGame = await storage.getGame(gameCode);
              broadcast(gameCode, { type: 'game_state', game: finalGame });
            }
          } catch (e) {
            ws.send(JSON.stringify({ type: 'error', message: 'Invalid move' }));
          }
        }
      } catch (e) {
        console.error('WS Error:', e);
      }
    });

    ws.on('close', () => {
      if (gameCode && rooms.has(gameCode)) {
        rooms.get(gameCode)!.delete(ws);
        if (rooms.get(gameCode)!.size === 0) rooms.delete(gameCode);
      }
    });
  });

  function broadcast(code: string, message: any) {
    if (rooms.has(code)) {
      const payload = JSON.stringify(message);
      rooms.get(code)!.forEach(client => {
        if (client.readyState === WebSocket.OPEN) client.send(payload);
      });
    }
  }

  return httpServer;
}
